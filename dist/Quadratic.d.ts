export default class Quadratic {
    private _a;
    private _b;
    private _c;
    constructor();
    get a(): number;
    set a(v: number);
    get b(): number;
    set b(v: number);
    get c(): number;
    set c(v: number);
    get p(): number;
    get q(): number;
    initGeneralForm(a: number, b: number, c: number): this;
    initStandardForm(a: number, p: number, q: number): this;
    initFactorizationForm(a: number, s: number, t: number): this;
    initByApexAndPassPoint(p: number, q: number, x: number, y: number): this;
    initByAxisAnd2PassPoints(axisX: number, x1: number, y1: number, x2: number, y2: number): this;
    initBy3PassPoints(x1: number, y1: number, x2: number, y2: number, x3: number, y3: number): this;
    fx(x: number): number;
    getPoints(fromX: number, toX: number, step: number): number[];
    getPointsOfSlopeAtYTangent(fromX: number, toX: number): number[];
    get apex(): {
        x: number;
        y: number;
    };
    get axis(): number;
    get isInvalid(): boolean;
    get hasApex(): boolean;
    get max(): number | undefined;
    get min(): number | undefined;
    get discriminant(): number;
    get solution(): number[] | undefined;
    get isPositiveDefinite(): boolean;
    get isNegativeDefinite(): boolean;
    toStringOfSlope(fixed?: number): string;
    toStringOfAxis(fixed?: number): string;
    toStringOfApex(fixed?: number): string;
    toStringOfLatexAPQ(fixed?: number): string;
    toStringOfLatexABC(fixed?: number): string;
    toStringAboutShape(): "" | "上に凸" | "下に凸";
    toString(): string;
    static calcP_By_ab(a: number, b: number): number;
    static calcQ_By_abc(a: number, b: number, c: number): number;
    static calcB_By_ap(a: number, p: number): number;
    static calcB_By_ast(a: number, s: number, t: number): number;
    static calcC_By_pq(a: number, p: number, q: number): number;
    static calcC_By_ast(a: number, s: number, t: number): number;
    static calcA_By_pqxy(p: number, q: number, x: number, y: number): number;
    static calcA_By_axixX_x1y1_x2y2(axisX: number, x1: number, y1: number, x2: number, y2: number): number;
    static calcQ_By_axixX_x1y1_x2y2(axisX: number, x1: number, y1: number, x2: number, y2: number): number;
    static calcA_By_x1y1_x2y2_x3y3(x1: number, y1: number, x2: number, y2: number, x3: number, y3: number): number;
    static calcB_By_x1y1_x2y2_x3y3(x1: number, y1: number, x2: number, y2: number, x3: number, y3: number): number;
    static calcC_By_x1y1_x2y2_x3y3(x1: number, y1: number, x2: number, y2: number, x3: number, y3: number): number;
    static discriminant(a: number, b: number, c: number): number;
    static solution(a: number, b: number, c: number): number[] | undefined;
    static isValidA(a: number): boolean;
    static hasApex(p: number, q: number): boolean;
    static isPositiveDefinite(a: number, b: number, c: number): boolean;
    static isNegativeDefinite(a: number, b: number, c: number): boolean;
    static intersect(a: Quadratic, b: Quadratic): {
        count: number;
        points: number[];
    };
}
//# sourceMappingURL=Quadratic.d.ts.map